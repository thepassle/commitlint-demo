'use strict';

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _test = require('@commitlint/test');

var _ava = require('ava');

var _ava2 = _interopRequireDefault(_ava);

var _execa = require('execa');

var _execa2 = _interopRequireDefault(_execa);

var _lodash = require('lodash');

var _sander = require('sander');

var sander = _interopRequireWildcard(_sander);

var _stringToStream = require('string-to-stream');

var _stringToStream2 = _interopRequireDefault(_stringToStream);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const bin = _path2.default.join(__dirname, './cli.js');

const cli = (args, options) => (input = '') => {
	const c = (0, _execa2.default)(bin, args, {
		capture: ['stdout'],
		cwd: options.cwd,
		env: options.env
	});
	(0, _stringToStream2.default)(input).pipe(c.stdin);
	return c.catch(err => err);
};

(0, _ava2.default)('should throw when called without [input]', t => new Promise(function ($return, $error) {
	var cwd, actual;
	return Promise.resolve(_test.git.bootstrap('fixtures/default')).then(function ($await_1) {
		try {
			cwd = $await_1;
			return Promise.resolve(cli([], { cwd })()).then(function ($await_2) {
				try {
					actual = $await_2;

					t.is(actual.code, 1);
					return $return();
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should reprint input from stdin', t => new Promise(function ($return, $error) {
	var cwd, actual;
	return Promise.resolve(_test.git.bootstrap('fixtures/default')).then(function ($await_3) {
		try {
			cwd = $await_3;
			return Promise.resolve(cli([], { cwd })('foo: bar')).then(function ($await_4) {
				try {
					actual = $await_4;

					t.true(actual.stdout.includes('foo: bar'));
					return $return();
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should produce no success output with --quiet flag', t => new Promise(function ($return, $error) {
	var cwd, actual;
	return Promise.resolve(_test.git.bootstrap('fixtures/default')).then(function ($await_5) {
		try {
			cwd = $await_5;
			return Promise.resolve(cli(['--quiet'], { cwd })('foo: bar')).then(function ($await_6) {
				try {
					actual = $await_6;

					t.is(actual.stdout, '');
					t.is(actual.stderr, '');
					return $return();
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should produce no success output with -q flag', t => new Promise(function ($return, $error) {
	var cwd, actual;
	return Promise.resolve(_test.git.bootstrap('fixtures/default')).then(function ($await_7) {
		try {
			cwd = $await_7;
			return Promise.resolve(cli(['-q'], { cwd })('foo: bar')).then(function ($await_8) {
				try {
					actual = $await_8;

					t.is(actual.stdout, '');
					t.is(actual.stderr, '');
					return $return();
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should fail for input from stdin without rules', t => new Promise(function ($return, $error) {
	var cwd, actual;
	return Promise.resolve(_test.git.bootstrap('fixtures/empty')).then(function ($await_9) {
		try {
			cwd = $await_9;
			return Promise.resolve(cli([], { cwd })('foo: bar')).then(function ($await_10) {
				try {
					actual = $await_10;

					t.is(actual.code, 1);
					return $return();
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should succeed for input from stdin with rules', t => new Promise(function ($return, $error) {
	var cwd, actual;
	return Promise.resolve(_test.git.bootstrap('fixtures/default')).then(function ($await_11) {
		try {
			cwd = $await_11;
			return Promise.resolve(cli([], { cwd })('type: bar')).then(function ($await_12) {
				try {
					actual = $await_12;

					t.is(actual.code, 0);
					return $return();
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should fail for input from stdin with rule from rc', t => new Promise(function ($return, $error) {
	var cwd, actual;
	return Promise.resolve(_test.git.bootstrap('fixtures/simple')).then(function ($await_13) {
		try {
			cwd = $await_13;
			return Promise.resolve(cli([], { cwd })('foo: bar')).then(function ($await_14) {
				try {
					actual = $await_14;

					t.true(actual.stdout.includes('type must not be one of [foo]'));
					t.is(actual.code, 1);
					return $return();
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should work with --config option', t => new Promise(function ($return, $error) {
	var file, cwd, actual;
	file = 'config/commitlint.config.js';
	return Promise.resolve(_test.git.bootstrap('fixtures/specify-config-file')).then(function ($await_15) {
		try {
			cwd = $await_15;
			return Promise.resolve(cli(['--config', file], { cwd })('foo: bar')).then(function ($await_16) {
				try {
					actual = $await_16;

					t.true(actual.stdout.includes('type must not be one of [foo]'));
					t.is(actual.code, 1);
					return $return();
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should fail for input from stdin with rule from js', t => new Promise(function ($return, $error) {
	var cwd, actual;
	return Promise.resolve(_test.git.bootstrap('fixtures/extends-root')).then(function ($await_17) {
		try {
			cwd = $await_17;
			return Promise.resolve(cli(['--extends', './extended'], { cwd })('foo: bar')).then(function ($await_18) {
				try {
					actual = $await_18;

					t.true(actual.stdout.includes('type must not be one of [foo]'));
					t.is(actual.code, 1);
					return $return();
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should produce no error output with --quiet flag', t => new Promise(function ($return, $error) {
	var cwd, actual;
	return Promise.resolve(_test.git.bootstrap('fixtures/simple')).then(function ($await_19) {
		try {
			cwd = $await_19;
			return Promise.resolve(cli(['--quiet'], { cwd })('foo: bar')).then(function ($await_20) {
				try {
					actual = $await_20;

					t.is(actual.stdout, '');
					t.is(actual.stderr, '');
					t.is(actual.code, 1);
					return $return();
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should produce no error output with -q flag', t => new Promise(function ($return, $error) {
	var cwd, actual;
	return Promise.resolve(_test.git.bootstrap('fixtures/simple')).then(function ($await_21) {
		try {
			cwd = $await_21;
			return Promise.resolve(cli(['-q'], { cwd })('foo: bar')).then(function ($await_22) {
				try {
					actual = $await_22;

					t.is(actual.stdout, '');
					t.is(actual.stderr, '');
					t.is(actual.code, 1);
					return $return();
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should work with husky commitmsg hook and git commit', () => new Promise(function ($return, $error) {
	var cwd;
	return Promise.resolve(_test.git.bootstrap('fixtures/husky/integration')).then(function ($await_23) {
		try {
			cwd = $await_23;
			return Promise.resolve(writePkg({ scripts: { commitmsg: `'${bin}' -e` } }, { cwd })).then(function ($await_24) {
				try {
					return Promise.resolve((0, _execa2.default)('npm', ['install'], { cwd })).then(function ($await_25) {
						try {
							return Promise.resolve((0, _execa2.default)('git', ['add', 'package.json'], { cwd })).then(function ($await_26) {
								try {
									return Promise.resolve((0, _execa2.default)('git', ['commit', '-m', '"test: this should work"'], { cwd })).then(function ($await_27) {
										try {
											return $return();
										} catch ($boundEx) {
											return $error($boundEx);
										}
									}.bind(this), $error);
								} catch ($boundEx) {
									return $error($boundEx);
								}
							}.bind(this), $error);
						} catch ($boundEx) {
							return $error($boundEx);
						}
					}.bind(this), $error);
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should work with husky commitmsg hook in sub packages', () => new Promise(function ($return, $error) {
	var upper, cwd;
	return Promise.resolve(_test.git.bootstrap('fixtures/husky')).then(function ($await_28) {
		try {
			upper = $await_28;
			cwd = _path2.default.join(upper, 'integration');
			return Promise.resolve(writePkg({ scripts: { commitmsg: `'${bin}' -e` } }, { cwd: upper })).then(function ($await_29) {
				try {
					return Promise.resolve((0, _execa2.default)('npm', ['install'], { cwd })).then(function ($await_30) {
						try {
							return Promise.resolve((0, _execa2.default)('git', ['add', 'package.json'], { cwd })).then(function ($await_31) {
								try {
									return Promise.resolve((0, _execa2.default)('git', ['commit', '-m', '"test: this should work"'], { cwd })).then(function ($await_32) {
										try {
											return $return();
										} catch ($boundEx) {
											return $error($boundEx);
										}
									}.bind(this), $error);
								} catch ($boundEx) {
									return $error($boundEx);
								}
							}.bind(this), $error);
						} catch ($boundEx) {
							return $error($boundEx);
						}
					}.bind(this), $error);
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should work with husky via commitlint -e $GIT_PARAMS', () => new Promise(function ($return, $error) {
	var cwd;
	return Promise.resolve(_test.git.bootstrap('fixtures/husky/integration')).then(function ($await_33) {
		try {
			cwd = $await_33;
			return Promise.resolve(writePkg({ scripts: { commitmsg: `'${bin}' -e $GIT_PARAMS` } }, { cwd })).then(function ($await_34) {
				try {
					return Promise.resolve((0, _execa2.default)('npm', ['install'], { cwd })).then(function ($await_35) {
						try {
							return Promise.resolve((0, _execa2.default)('git', ['add', 'package.json'], { cwd })).then(function ($await_36) {
								try {
									return Promise.resolve((0, _execa2.default)('git', ['commit', '-m', '"test: this should work"'], { cwd })).then(function ($await_37) {
										try {
											return $return();
										} catch ($boundEx) {
											return $error($boundEx);
										}
									}.bind(this), $error);
								} catch ($boundEx) {
									return $error($boundEx);
								}
							}.bind(this), $error);
						} catch ($boundEx) {
							return $error($boundEx);
						}
					}.bind(this), $error);
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should work with husky via commitlint -e %GIT_PARAMS%', () => new Promise(function ($return, $error) {
	var cwd;
	return Promise.resolve(_test.git.bootstrap('fixtures/husky/integration')).then(function ($await_38) {
		try {
			cwd = $await_38;
			return Promise.resolve(writePkg({ scripts: { commitmsg: `'${bin}' -e %GIT_PARAMS%` } }, { cwd })).then(function ($await_39) {
				try {
					return Promise.resolve((0, _execa2.default)('npm', ['install'], { cwd })).then(function ($await_40) {
						try {
							return Promise.resolve((0, _execa2.default)('git', ['add', 'package.json'], { cwd })).then(function ($await_41) {
								try {
									return Promise.resolve((0, _execa2.default)('git', ['commit', '-m', '"test: this should work"'], { cwd })).then(function ($await_42) {
										try {
											return $return();
										} catch ($boundEx) {
											return $error($boundEx);
										}
									}.bind(this), $error);
								} catch ($boundEx) {
									return $error($boundEx);
								}
							}.bind(this), $error);
						} catch ($boundEx) {
							return $error($boundEx);
						}
					}.bind(this), $error);
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should work with husky via commitlint -e $HUSKY_GIT_PARAMS', () => new Promise(function ($return, $error) {
	var cwd;
	return Promise.resolve(_test.git.bootstrap('fixtures/husky/integration')).then(function ($await_43) {
		try {
			cwd = $await_43;
			return Promise.resolve(writePkg({ scripts: { commitmsg: `'${bin}' -e $HUSKY_GIT_PARAMS` } }, { cwd })).then(function ($await_44) {
				try {
					return Promise.resolve((0, _execa2.default)('npm', ['install'], { cwd })).then(function ($await_45) {
						try {
							return Promise.resolve((0, _execa2.default)('git', ['add', 'package.json'], { cwd })).then(function ($await_46) {
								try {
									return Promise.resolve((0, _execa2.default)('git', ['commit', '-m', '"test: this should work"'], { cwd })).then(function ($await_47) {
										try {
											return $return();
										} catch ($boundEx) {
											return $error($boundEx);
										}
									}.bind(this), $error);
								} catch ($boundEx) {
									return $error($boundEx);
								}
							}.bind(this), $error);
						} catch ($boundEx) {
							return $error($boundEx);
						}
					}.bind(this), $error);
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should work with husky via commitlint -e %HUSKY_GIT_PARAMS%', () => new Promise(function ($return, $error) {
	var cwd;
	return Promise.resolve(_test.git.bootstrap('fixtures/husky/integration')).then(function ($await_48) {
		try {
			cwd = $await_48;
			return Promise.resolve(writePkg({ scripts: { commitmsg: `'${bin}' -e %HUSKY_GIT_PARAMS%` } }, { cwd })).then(function ($await_49) {
				try {
					return Promise.resolve((0, _execa2.default)('npm', ['install'], { cwd })).then(function ($await_50) {
						try {
							return Promise.resolve((0, _execa2.default)('git', ['add', 'package.json'], { cwd })).then(function ($await_51) {
								try {
									return Promise.resolve((0, _execa2.default)('git', ['commit', '-m', '"test: this should work"'], { cwd })).then(function ($await_52) {
										try {
											return $return();
										} catch ($boundEx) {
											return $error($boundEx);
										}
									}.bind(this), $error);
								} catch ($boundEx) {
									return $error($boundEx);
								}
							}.bind(this), $error);
						} catch ($boundEx) {
							return $error($boundEx);
						}
					}.bind(this), $error);
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should allow reading of environment variables for edit file, succeeding if valid', t => new Promise(function ($return, $error) {
	var cwd, actual;
	return Promise.resolve(_test.git.bootstrap('fixtures/simple')).then(function ($await_53) {
		try {
			cwd = $await_53;
			return Promise.resolve(sander.writeFile(cwd, 'commit-msg-file', 'foo')).then(function ($await_54) {
				try {
					return Promise.resolve(cli(['--env', 'variable'], {
						cwd,
						env: { variable: 'commit-msg-file' }
					})()).then(function ($await_55) {
						try {
							actual = $await_55;

							t.is(actual.code, 0);
							return $return();
						} catch ($boundEx) {
							return $error($boundEx);
						}
					}.bind(this), $error);
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should allow reading of environment variables for edit file, failing if invalid', t => new Promise(function ($return, $error) {
	var cwd, actual;
	return Promise.resolve(_test.git.bootstrap('fixtures/simple')).then(function ($await_56) {
		try {
			cwd = $await_56;
			return Promise.resolve(sander.writeFile(cwd, 'commit-msg-file', 'foo: bar\n\nFoo bar bizz buzz.\n\nCloses #123.')).then(function ($await_57) {
				try {
					return Promise.resolve(cli(['--env', 'variable'], {
						cwd,
						env: { variable: 'commit-msg-file' }
					})()).then(function ($await_58) {
						try {
							actual = $await_58;

							t.is(actual.code, 1);
							return $return();
						} catch ($boundEx) {
							return $error($boundEx);
						}
					}.bind(this), $error);
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should pick up parser preset and fail accordingly', t => new Promise(function ($return, $error) {
	var cwd, actual;
	return Promise.resolve(_test.git.bootstrap('fixtures/parser-preset')).then(function ($await_59) {
		try {
			cwd = $await_59;
			return Promise.resolve(cli(['--parser-preset', './parser-preset'], { cwd })('type(scope): subject')).then(function ($await_60) {
				try {
					actual = $await_60;

					t.is(actual.code, 1);
					t.true(actual.stdout.includes('may not be empty'));
					return $return();
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should pick up parser preset and succeed accordingly', t => new Promise(function ($return, $error) {
	var cwd, actual;
	return Promise.resolve(_test.git.bootstrap('fixtures/parser-preset')).then(function ($await_61) {
		try {
			cwd = $await_61;
			return Promise.resolve(cli(['--parser-preset', './parser-preset'], { cwd })('----type(scope): subject')).then(function ($await_62) {
				try {
					actual = $await_62;

					t.is(actual.code, 0);
					return $return();
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should pick up config from outside git repo and fail accordingly', t => new Promise(function ($return, $error) {
	var outer, cwd, actual;
	return Promise.resolve(_test.fix.bootstrap('fixtures/outer-scope')).then(function ($await_63) {
		try {
			outer = $await_63;
			return Promise.resolve(_test.git.init(_path2.default.join(outer, 'inner-scope'))).then(function ($await_64) {
				try {
					cwd = $await_64;
					return Promise.resolve(cli([], { cwd })('inner: bar')).then(function ($await_65) {
						try {
							actual = $await_65;

							t.is(actual.code, 1);
							return $return();
						} catch ($boundEx) {
							return $error($boundEx);
						}
					}.bind(this), $error);
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should pick up config from outside git repo and succeed accordingly', t => new Promise(function ($return, $error) {
	var outer, cwd, actual;
	return Promise.resolve(_test.fix.bootstrap('fixtures/outer-scope')).then(function ($await_66) {
		try {
			outer = $await_66;
			return Promise.resolve(_test.git.init(_path2.default.join(outer, 'inner-scope'))).then(function ($await_67) {
				try {
					cwd = $await_67;
					return Promise.resolve(cli([], { cwd })('outer: bar')).then(function ($await_68) {
						try {
							actual = $await_68;

							t.is(actual.code, 0);
							return $return();
						} catch ($boundEx) {
							return $error($boundEx);
						}
					}.bind(this), $error);
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should pick up config from inside git repo with precedence and succeed accordingly', t => new Promise(function ($return, $error) {
	var outer, cwd, actual;
	return Promise.resolve(_test.fix.bootstrap('fixtures/inner-scope')).then(function ($await_69) {
		try {
			outer = $await_69;
			return Promise.resolve(_test.git.init(_path2.default.join(outer, 'inner-scope'))).then(function ($await_70) {
				try {
					cwd = $await_70;
					return Promise.resolve(cli([], { cwd })('inner: bar')).then(function ($await_71) {
						try {
							actual = $await_71;

							t.is(actual.code, 0);
							return $return();
						} catch ($boundEx) {
							return $error($boundEx);
						}
					}.bind(this), $error);
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should pick up config from inside git repo with precedence and fail accordingly', t => new Promise(function ($return, $error) {
	var outer, cwd, actual;
	return Promise.resolve(_test.fix.bootstrap('fixtures/inner-scope')).then(function ($await_72) {
		try {
			outer = $await_72;
			return Promise.resolve(_test.git.init(_path2.default.join(outer, 'inner-scope'))).then(function ($await_73) {
				try {
					cwd = $await_73;
					return Promise.resolve(cli([], { cwd })('outer: bar')).then(function ($await_74) {
						try {
							actual = $await_74;

							t.is(actual.code, 1);
							return $return();
						} catch ($boundEx) {
							return $error($boundEx);
						}
					}.bind(this), $error);
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should handle --amend with signoff', () => new Promise(function ($return, $error) {
	var cwd;
	return Promise.resolve(_test.git.bootstrap('fixtures/signoff')).then(function ($await_75) {
		try {
			cwd = $await_75;
			return Promise.resolve(writePkg({ scripts: { commitmsg: `'${bin}' -e` } }, { cwd })).then(function ($await_76) {
				try {
					return Promise.resolve((0, _execa2.default)('npm', ['install'], { cwd })).then(function ($await_77) {
						try {
							return Promise.resolve((0, _execa2.default)('git', ['add', 'package.json'], { cwd })).then(function ($await_78) {
								try {
									return Promise.resolve((0, _execa2.default)('git', ['commit', '-m', '"test: this should work"', '--signoff'], { cwd })).then(function ($await_79) {
										try {
											return Promise.resolve((0, _execa2.default)('git', ['commit', '--amend', '--no-edit'], { cwd })).then(function ($await_80) {
												try {
													return $return();
												} catch ($boundEx) {
													return $error($boundEx);
												}
											}.bind(this), $error);
										} catch ($boundEx) {
											return $error($boundEx);
										}
									}.bind(this), $error);
								} catch ($boundEx) {
									return $error($boundEx);
								}
							}.bind(this), $error);
						} catch ($boundEx) {
							return $error($boundEx);
						}
					}.bind(this), $error);
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should handle linting with issue prefixes', t => new Promise(function ($return, $error) {
	var cwd, actual;
	return Promise.resolve(_test.git.bootstrap('fixtures/issue-prefixes')).then(function ($await_81) {
		try {
			cwd = $await_81;
			return Promise.resolve(cli([], { cwd })('foobar REF-1')).then(function ($await_82) {
				try {
					actual = $await_82;

					t.is(actual.code, 0);
					return $return();
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should print full commit message when input from stdin fails', t => new Promise(function ($return, $error) {
	var cwd, input, actual;
	return Promise.resolve(_test.git.bootstrap('fixtures/simple')).then(function ($await_83) {
		try {
			cwd = $await_83;
			input = 'foo: bar\n\nFoo bar bizz buzz.\n\nCloses #123.';
			return Promise.resolve(cli([], { cwd })(input)).then(function ($await_84) {
				try {
					actual = $await_84;


					t.true(actual.stdout.includes(input));
					t.is(actual.code, 1);
					return $return();
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should not print full commit message when input succeeds', t => new Promise(function ($return, $error) {
	var cwd, message, actual;
	return Promise.resolve(_test.git.bootstrap('fixtures/default')).then(function ($await_85) {
		try {
			cwd = $await_85;
			message = 'type: bar\n\nFoo bar bizz buzz.\n\nCloses #123.';
			return Promise.resolve(cli([], { cwd })(message)).then(function ($await_86) {
				try {
					actual = $await_86;


					t.false(actual.stdout.includes(message));
					t.true(actual.stdout.includes(message.split('\n')[0]));
					t.is(actual.code, 0);
					return $return();
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should fail for invalid formatters from configuration', t => new Promise(function ($return, $error) {
	var cwd, actual;
	return Promise.resolve(_test.git.bootstrap('fixtures/custom-formatter')).then(function ($await_87) {
		try {
			cwd = $await_87;
			return Promise.resolve(cli([], { cwd })('foo: bar')).then(function ($await_88) {
				try {
					actual = $await_88;

					t.true(actual.stderr.includes(`Using format custom-formatter, but cannot find the module`));
					t.is(actual.stdout, '');
					t.is(actual.code, 1);
					return $return();
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should fail for invalid formatters from flags', t => new Promise(function ($return, $error) {
	var cwd, actual;
	return Promise.resolve(_test.git.bootstrap('fixtures/custom-formatter')).then(function ($await_89) {
		try {
			cwd = $await_89;
			return Promise.resolve(cli(['--format', 'through-flag'], { cwd })('foo: bar')).then(function ($await_90) {
				try {
					actual = $await_90;

					t.true(actual.stderr.includes(`Using format through-flag, but cannot find the module`));
					t.is(actual.stdout, '');
					t.is(actual.code, 1);
					return $return();
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should work with absolute formatter path', t => new Promise(function ($return, $error) {
	var formatterPath, cwd, actual;
	formatterPath = _path2.default.resolve(__dirname, '../fixtures/custom-formatter/formatters/custom.js');
	return Promise.resolve(_test.git.bootstrap('fixtures/custom-formatter')).then(function ($await_91) {
		try {
			cwd = $await_91;
			return Promise.resolve(cli(['--format', formatterPath], { cwd })('test: this should work')).then(function ($await_92) {
				try {
					actual = $await_92;


					t.true(actual.stdout.includes('custom-formatter-ok'));
					t.is(actual.code, 0);
					return $return();
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

(0, _ava2.default)('should work with relative formatter path', t => new Promise(function ($return, $error) {
	var cwd, actual;
	return Promise.resolve(_test.git.bootstrap('fixtures/custom-formatter')).then(function ($await_93) {
		try {
			cwd = _path2.default.resolve($await_93, './formatters');
			return Promise.resolve(cli(['--format', './custom.js'], { cwd })('test: this should work')).then(function ($await_94) {
				try {
					actual = $await_94;


					t.true(actual.stdout.includes('custom-formatter-ok'));
					t.is(actual.code, 0);
					return $return();
				} catch ($boundEx) {
					return $error($boundEx);
				}
			}.bind(this), $error);
		} catch ($boundEx) {
			return $error($boundEx);
		}
	}.bind(this), $error);
}.bind(this)));

function writePkg(payload, options) {
	return new Promise(function ($return, $error) {
		var pkgPath, pkg, result;
		pkgPath = _path2.default.join(options.cwd, 'package.json');
		return Promise.resolve(sander.readFile(pkgPath)).then(function ($await_95) {
			try {
				pkg = JSON.parse($await_95);
				result = (0, _lodash.merge)(pkg, payload);
				return Promise.resolve(sander.writeFile(pkgPath, JSON.stringify(result, null, '  '))).then(function ($await_96) {
					try {
						return $return();
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
}
//# sourceMappingURL=cli.test.js.map